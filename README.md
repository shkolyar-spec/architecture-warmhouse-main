# Задание 1. Анализ и планирование

<aside>

Чтобы составить документ с описанием текущей архитектуры приложения, можно часть информации взять из описания компании и условия задания. Это нормально.

</aside>

### 1. Описание функциональности монолитного приложения

**Управление отоплением:**

- Пользователи могут:
	- включать/выключать систему отопления в своем доме


- Система поддерживает:
	- Управление датчиками
	- Регистрацию датчиков

**Мониторинг температуры:**

- Пользователи могут:
	- Просматривать текущую температуру в своих домах через веб-интерфейс

- Система поддерживает:
	- Получать данные с датчиков

### 2. Анализ архитектуры монолитного приложения

- **Язык программирования**: Go
- **База данных**: PostgreSQL
- **Архитектура**: Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.
- **Взаимодействие**: Синхронное, запросы обрабатываются последовательно.
- **Масштабируемость**: Ограничена, так как монолит сложно масштабировать по частям.
- **Развертывание**: Требует остановки всего приложения.
- **Объем**: 100 веб клиентов, 100 модулей управления отоплением
### 3. Определение доменов и границы контекстов

**1. Продажа датчиков (Sales)**
Домен отвечает за продажу комплектов и устройств:
- формирование заказов на комплекты/устройства
- расчёт стоимости и статусов заказов
- инициирование оплаты во внешней платёжной системе
Граница контекста: микросервис «Продажа датчиков» не знает внутренней логики управления устройствами и телеметрии, он оперирует только заказами, позициями заказов и статусами оплаты.

**2. Управление датчиками (Device Management)**
Домен отвечает за эксплуатацию устройств в домах пользователя:
- регистрация и привязка устройства к дому/комнате
- включение/выключение устройств, изменение параметров (температура и т.п.)
- запуск сценариев управления (например, «отключить свет при уходе»)
Граница контекста: микросервис управления датчиками отвечает только за текущее состояние и команды к устройствам. Исторические данные (телеметрия) и платежи остаются в других контекстах.

**3. НСИ / мастер-данные (Master Data)**
Домен хранит справочную информацию, которая используется несколькими сервисами:
- справочники устройств
- дома и их базовые атрибуты
- атрибуты пользователей
Граница контекста: «НСИ» выступает единым источником для справочных данных. Другие сервисы не изменяют эти сущности напрямую, а обращаются за даннымм.

**4. Управление пользователями (User Management)**
Домен отвечает за жизненный цикл пользователя в системе:
- создание и изменение профиля пользователя
- связь пользователя с домами и устройствами (например, права доступа к конкретному дому)
- хранение пользовательских настроек, не относящихся к безопасности
Граница контекста: ведение данных пользователя (профиль, связи, настройки).

**5. Сервис авторизации (Auth Service)**
Домен безопасности:
- аутентификация по логину/паролю
- выдача access- и refresh-токенов (JWT)
- валидация токенов при обращении к API
- отзыв refresh-токенов и управление сессиями (через Redis)
Граница контекста: сервис авторизации не знает бизнес-логики заказов, устройств и т.д. Он работает только с учётными данными и токенами, предоставляя остальным сервисам информацию «кто это» и «какие у него права».

**6. Веб-приложение (Web App)**
Клиентский контекст:
- единая точка взаимодействия пользователя с системой
- отображение данных из разных микросервисов (устройства, дома, заказы, телеметрия)
- отправка команд к микросервисам ландшафта
Граница контекста: во фронтенде нет бизнес-правил доменов — он только оркестрирует вызовы backend-сервисов и отвечает за UI.

**7. Интеграционный шлюз (Integration Gateway)**
Домен интеграций с внешними системами:
- взаимодействие с партнёрскими системами и внешними API
- адаптация протоколов (например, MQTT/HTTP) и форматов данных
Граница контекста: единая точка взаимодействия с внешними систем. Интеграционный шлюз скрывает от внутренних сервисов детали взаимодействия с внешними системами.


**8. API Gateway**
Домен:
- принимает входящие HTTP-запросы от клиентов
- оркестрирует и направляет запросы соответствующим микросервисам
- обеспечивает балансировку нагрузки и кэширование
Граница контекста: API Gateway не знает бизнес-логики доменов — он работает только с HTTP-запросами и ответами.


### **4. Проблемы монолитного решения**

- **Развертывание и обновление**:  Выполняется медленно, поскольку
	1) весь сервис должен быть перезапущен при изменении любого компонента
	2) компоненты тесно связаны между собой и новые функции потребует много времени для тестирования и поставки

- **Масштабируемость**: Неэффективна, поскольку
	1) увеличение нагрузки на один из компонентов системы потребует масштабирования всей системы.
	2) Масштабирование системы возможно горизонтально с увеличением количества серверов, но это потребует сложных механизмов распределения нагрузки и координации.
	3) Масштбариование горизонтально с увеличением количества серверов также не эффективно, поскольку увеличивается время ответа системы. (а точно?) 
		3.1) Увеличение количества серверов потребует сложных механизмов распределения нагрузки и координации.
	3) Масштабирование вертикально с увеличением количества процессов на одном сервере также не эффективно, поскольку увеличивается время ответа системы. (а точно?) 
	- **Вывод**: При увеличении нагрузки масштабирование будет усложнено.
	
- **Гибкость в выборе технологий**: Все компоненты работают в одной технологической среде, что ограничивает гибкость выбора технологий.

- **Устойчивость к отказам**: Если один из компонентов системы отказывается работать, весь сервис становится недоступным.

- **Тестирование**: Тестирование занимает много времени, так как необходимо проводить регресс тестирование всего функционала системы

- **Производительность**:
	1) Из-за синхронного выполнения запросов производительность может быть ограничена.
	2) Из-за выросшей нагрузки на один из компонентов повлияет на производительность всей системы.

**Вывод:** Монолитный подход не является эффективным для целевого решения, требующего масштабирования и гибкости.

### 5. Визуализация контекста системы — диаграмма С4



[Context.puml](/docs/PlantUml/Context.puml)


# Задание 2. Проектирование микросервисной архитектуры


**Диаграмма контейнеров (Containers)**

[C4_Container.puml](/docs/PlantUml/C4_Container.puml)


**Диаграмма компонентов (Components)**

[C4_Component_Auth_Service.puml](/docs/PlantUml/C4_Component_Auth_Service.puml)


[C4_Component_Billing.puml](/docs/PlantUml/C4_Component_Billing.puml)



[C4_Component_Integration_Gateway.puml](/docs/PlantUml/C4_Component_Integration_Gateway.puml)



[C4_Component_Master_data.puml](/docs/PlantUml/C4_Component_Master_data.puml)


[C4_Component_Module_Management.puml](/docs/PlantUml/C4_Component_Module_Management.puml)

[C4_Component_User_Management.puml](/docs/PlantUml/C4_Component_User_Management.puml)

[C4_Component_Web_App.puml](/docs/PlantUml/C4_Component_Web_App.puml)


**Диаграмма кода (Code)**

[C4_Code_token_service.puml](/docs/PlantUml/C4_Code_token_service.puml)


# Задание 3. Разработка ER-диаграммы


[ER_диаграмма.puml](/docs/PlantUml/ER_диаграмма.puml)


# Задание 4. Создание и документирование API

### 1. Тип API

Для взаимодействия между микросервисами (Сервис авторизации, Продажа датчиков, Управление датчиками, Управление пользователями) я выбрал **синхронный REST API**.

**Причины выбора синхронного REST API:**

1. **Характер операций — запрос–ответ.**
   Для авторизации, создания заказов и управления устройствами пользователю нужен немедленный ответ:
   - успешен ли вход (Auth Service)
   - создан ли заказ и каков его идентификатор (Sales)
   - принята ли команда к устройству (Device Management)
   - существует ли пользователь и каковы его данные (User Management)
   Такие операции описываются синхронными запросами.

2. **Простота интеграции с веб-приложением.**
   Фронтенд (Web App) работает поверх HTTP/HTTPS и базовым сценарием для него является именно REST-подход. Это упрощает реализацию, отладку и использование стандартных инструментов (Swagger UI, Postman, браузерные dev-tools).

3. **Небольшой объём и частота вызовов.**
   Ключевые операции Auth/Sales/Device Management в рамках текущего решения не предполагают экстремально высокой частоты вызовов. Синхронные HTTP-вызовы здесь достаточно эффективны и не усложняют архитектуру.

5. **Асинхронность оставлена для телеметрии и событий.**
   Для потоковых данных (телеметрия) в целевой архитектуре можно использовать асинхронные механизмы. Но в рамках данного задания API для этих сервисов не детализировался, поэтому для выбранных микросервисов указан синхронный REST.

Таким образом, синхронный REST API даёт баланс между простотой реализации, понятностью для разработчиков и достаточностью для основных сценариев авторизации, продажи датчиков, управления устройствами и пользователями.


### 2. Документация API

Здесь приложите ссылки на документацию API для микросервисов, которые вы спроектировали в первой части проектной работы. Для документирования используйте Swagger/OpenAPI или AsyncAPI.

# Задание 5. Работа с docker и docker-compose

1) Реализован отдельный микросервис temperature-api, который возвращает случайное значение температуры для указанной локации.

2) Проект упакован в Docker.

3) Добавлен docker-compose c smart_home + Postgres + temperature-api


